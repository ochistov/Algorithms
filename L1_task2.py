# -*- coding: utf-8 -*-
# Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6. 
# Выполнить над числом 5 побитовый сдвиг вправо и влево на два знака. 
# Объяснить полученный результат.

digit1 = 5
digit2 = 6

'''"ИЛИ" - если хотя бы один бит из сравниваемых - 1, в результате 1. Иначе - 0.'''
bit_or = digit1 | digit2

'''"Исключающее ИЛИ" - как и ИЛИ, но 1 только в том случае, если 1 только в ОДНОМ из сравниваемых
Если в обоих нули или единицы, в результате - 0.'''
bit_xor = digit1 ^ digit2

'''"И" - результат 1, только если 1 в обоих сравниваемых. В остальных случаях 0'''
bit_and = digit1 & digit2 

'''Побитовое отрицание меняет 1 на 0 и наоборот.'''
bit_not_digit1 = ~digit1
bit_not_digit2 = ~digit2

'''Побитовый сдвиг вправо. Значение левого битового числа сдвигается вправо
на количество бит указанных в правом битовом числе.'''
bit_shift_right = digit1 >> 2

'''Побитовый сдвиг влево. Значение левого битового числа сдвигается влево
на количество бит указанных в правом битовом числе.'''
bit_shift_left = digit1 << 2

print(f"""Число 5 в битовом представлении - {bin(digit1)}\n\
Число 6 в битовом представлении - {bin(digit2)}\n\
Побитовое «ИЛИ» (OR) для {bin(digit1)} и {bin(digit2)}: {bin(bit_or)} ({bit_or})\n\
Исключающее «ИЛИ» (XOR) для {bin(digit1)} и {bin(digit2)}: {bin(bit_xor)} ({bit_xor})\n\
Побитовое «И» (AND) для {bin(digit1)} и {bin(digit2)}: {bin(bit_and)} ({bit_and})\n\
Побитовое отрицание (NOT) для {bin(digit1)}: {bin(bit_not_digit1)} ({bit_not_digit1}) \
и для {bin(digit2)}: {bin(bit_not_digit2)} ({bit_not_digit2})\n\
Битовый сдвиг вправо для {bin(digit1)}: {bin(bit_shift_right)} ({bit_shift_right})\n\
Битовый сдвиг влево для {bin(digit1)}: {bin(bit_shift_left)} ({bit_shift_left})""")